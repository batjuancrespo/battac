<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dictado Radiológico v21 (Gestión Modal Fix)</title>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>

    <!-- Firebase SDK Imports -->
    <script type="module">
      const firebaseConfig = { /* ... Tu config ... */
         apiKey: "AIzaSyA_VQH1y-px8-QF3gMw3VOPjiiU1OefDBo", authDomain: "almacena-correcciones-dictado.firebaseapp.com", projectId: "almacena-correcciones-dictado", storageBucket: "almacena-correcciones-dictado.appspot.com", messagingSenderId: "209194920272", appId: "1:209194920272:web:ccbec69d0a5aa88789e455", measurementId: "G-6PQSKYMDP0"
       };
      const userId = "usuario_test_001";

      try {
            const fa=await import('https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js'); const fs=await import('https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js');
            window.firebaseApp=fa.initializeApp(firebaseConfig); window.db=fs.getFirestore(window.firebaseApp); window.doc=fs.doc; window.getDoc=fs.getDoc; window.setDoc=fs.setDoc; window.userId=userId; console.log("Firebase inicializado."); document.dispatchEvent(new CustomEvent('firebaseReady'));
      } catch (error) { console.error("Error inicializando Firebase:", error); alert("Error crítico: No se pudo inicializar la base de datos."); /* ... */ }
    </script>

    <style>
        /* --- Variables CSS --- */
        :root { /* Claro */ } body.dark-mode { /* Oscuro */ }
        /* ... Estilos CSS completos (sin cambios) ... */
         :root {
            --bg-color: #f4f4f4; --container-bg: #fff; --text-color: #333; --text-muted-color: #555; --heading-color: #333; --border-color: #ccc; --border-light-color: #eee; --border-dashed-color: #ddd; --link-color: #007bff;
            --button-primary-bg: #007bff; --button-primary-hover-bg: #0056b3; --button-primary-text: white; --button-secondary-bg: #6c757d; --button-secondary-hover-bg: #5a6268; --button-secondary-text: white;
            --button-success-bg: #28a745; --button-success-hover-bg: #218838; --button-success-text: white; --button-danger-bg: #dc3545; --button-danger-hover-bg: #c82333; --button-danger-text: white; --button-warning-bg: #ffc107; --button-warning-hover-bg: #e0a800; --button-warning-text: #212529;
            --button-info-bg: #17a2b8; --button-info-hover-bg: #138496; --button-info-text: white; --button-light-gray-bg: #e9e9e9; --button-light-gray-hover-bg: #d8d8d8; --button-light-gray-text: #333;
            --button-suggestion-bg: #f8f8f8; --button-suggestion-hover-bg: #e8e8e8; --button-suggestion-border: #ccc; --button-disabled-bg: #cccccc; --button-disabled-opacity: 0.7;
            --input-bg: white; --input-border: #ccc; --input-text: #333; --header-area-bg: #f9f9f9; --header-area-border: #eee; --status-listening-color: #777; --status-base-color: #555; --suggestions-bg: #eef; --suggestions-border: #cce;
            --slider-thumb-bg: #007bff; --slider-track-bg: #ddd; --switch-bg: #ccc; --switch-thumb-bg: white; --switch-checked-bg: #007bff;
            --modal-overlay-bg: rgba(0, 0, 0, 0.6); --modal-content-bg: var(--container-bg); --modal-border: var(--border-color);
        }
        body.dark-mode {
             --bg-color: #22272e; --container-bg: #2d333b; --text-color: #adbac7; --text-muted-color: #768390; --heading-color: #adbac7; --border-color: #444c56; --border-light-color: #373e47; --border-dashed-color: #444c56; --link-color: #539bf5;
             --button-primary-bg: #377ef0; --button-primary-hover-bg: #539bf5; --button-secondary-bg: #444c56; --button-secondary-hover-bg: #5d6774; --button-secondary-text: #adbac7;
             --button-success-bg: #347d39; --button-success-hover-bg: #46954a; --button-success-text: white; --button-danger-bg: #e5534b; --button-danger-hover-bg: #f47067;
             --button-warning-bg: #d9971a; --button-warning-hover-bg: #f0b72f; --button-warning-text: #22272e; --button-info-bg: #4387d9; --button-info-hover-bg: #539bf5; --button-light-gray-bg: #373e47; --button-light-gray-hover-bg: #444c56; --button-light-gray-text: #adbac7;
             --button-suggestion-bg: #373e47; --button-suggestion-hover-bg: #444c56; --button-suggestion-border: #5d6774; --button-disabled-bg: #444c56; --input-bg: #22272e; --input-border: #444c56; --input-text: #adbac7;
             --header-area-bg: #22272e; --header-area-border: #373e47; --status-listening-color: #768390; --status-base-color: #768390; --suggestions-bg: #2d333b; --suggestions-border: #444c56;
             --slider-thumb-bg: #539bf5; --slider-track-bg: #444c56; --switch-bg: #444c56; --switch-thumb-bg: #768390; --switch-checked-bg: #377ef0;
              --modal-overlay-bg: rgba(0, 0, 0, 0.7); --modal-border: var(--border-color);
        }
        body { font-family: sans-serif; line-height: 1.6; margin: 0; padding: 20px; background-color: var(--bg-color); color: var(--text-color); display: flex; justify-content: center; transition: background-color 0.3s ease, color 0.3s ease; }
        .layout-wrapper { display: flex; flex-direction: row; gap: 25px; width: 100%; max-width: 1400px; align-items: flex-start; }
        .main-content-area { flex: 3; display: flex; flex-direction: column; gap: 20px; }
        .suggestions-column { flex: 1; position: sticky; top: 20px; display: flex; flex-direction: column; gap: 20px; }
        .container { background-color: var(--container-bg); padding: 25px; border-radius: 8px; border: 1px solid var(--border-light-color); box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); transition: background-color 0.3s ease, border-color 0.3s ease; }
        h1, h2 { color: var(--heading-color); text-align: center; margin-top: 0; margin-bottom: 20px; }
        h3 { color: var(--text-muted-color); margin-top: 0; margin-bottom: 15px; border-bottom: 1px solid var(--border-light-color); padding-bottom: 8px; }
        .controls { text-align: center; padding: 15px; background-color: var(--container-bg); border-radius: 8px; border: 1px solid var(--border-color); }
        .controls button { padding: 12px 25px; font-size: 1.1em; margin: 5px; cursor: pointer; border: none; border-radius: 5px; transition: background-color 0.3s ease, opacity 0.3s ease; min-width: 150px; text-align: center; vertical-align: middle; }
        #toggleButton { color: var(--button-primary-text); } #toggleButton.start { background-color: var(--button-primary-bg); } #toggleButton.start:hover { background-color: var(--button-primary-hover-bg); } #toggleButton.stop { background-color: #dc3545; } #toggleButton.stop:hover { background-color: #c82333; }
        #correctTextButton { background-color: var(--button-success-bg); color: var(--button-success-text); } #correctTextButton:hover { background-color: var(--button-success-hover-bg); }
        #copyTextButton { background-color: var(--button-warning-bg); color: var(--button-warning-text); } #copyTextButton:hover { background-color: var(--button-warning-hover-bg); }
        .controls button:disabled { background-color: var(--button-disabled-bg); cursor: not-allowed; opacity: var(--button-disabled-opacity); }
        #status { margin-top: 15px; font-weight: bold; color: var(--status-base-color); min-height: 20px; } #status span { color: var(--status-listening-color); }
        .header-section { padding: 15px; background-color: var(--container-bg); border: 1px solid var(--border-color); border-radius: 8px; }
        #headerArea { display: block; width: 100%; box-sizing: border-box; padding: 10px; margin-bottom: 0; border: 1px solid var(--header-area-border); border-radius: 5px; background-color: var(--header-area-bg); color: var(--input-text); font-family: sans-serif; font-size: 1em; line-height: 1.5; resize: vertical; }
        .editor-container { position: relative; text-align: center; padding: 15px; border-radius: 8px; border: 1px solid var(--border-color); background-color: var(--container-bg); }
        #reportArea { width: 100%; box-sizing: border-box; min-height: 400px; padding: 15px; border: 1px solid var(--input-border); border-radius: 5px; font-size: 1.1em; line-height: 1.6; margin-bottom: 10px; background-color: var(--input-bg); color: var(--input-text); resize: vertical; }
        em, small { color: var(--text-muted-color); font-size: 0.9em; } .instructions { font-size: 0.9em; color: var(--text-muted-color); margin-bottom: 15px; }
        #technique-selection-container { padding: 20px; } #technique-selection-container h3 { margin-top: 0; text-align: center; } #techniqueButtons { display: flex; flex-direction: column; gap: 15px; }
        .technique-group { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; } #techniqueButtons button { padding: 8px 10px; font-size: 0.85em; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; min-width: 90px; text-align: center; flex-grow: 1; flex-basis: 90px; }
        #techniqueButtons button:active { transform: scale(0.97); } .btn-red { background-color: var(--button-danger-bg); color: var(--button-danger-text); } .btn-red:hover { background-color: var(--button-danger-hover-bg); } .btn-yellow { background-color: var(--button-warning-bg); color: var(--button-warning-text); } .btn-yellow:hover { background-color: var(--button-warning-hover-bg); } .btn-blue { background-color: var(--button-info-bg); color: var(--button-info-text); } .btn-blue:hover { background-color: var(--button-info-hover-bg); } .btn-gray { background-color: var(--button-light-gray-bg); color: var(--button-light-gray-text); } .btn-gray:hover { background-color: var(--button-light-gray-hover-bg); }
        .suggestions-container { padding: 15px; background-color: var(--suggestions-bg); border: 1px solid var(--suggestions-border); border-radius: 8px; text-align: left; max-height: 250px; overflow-y: auto; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .suggestion-item { padding: 8px 5px; margin-bottom: 8px; border-bottom: 1px dashed var(--border-dashed-color); display: flex; justify-content: space-between; align-items: center; font-size: 0.95em; } .suggestion-item:last-child { border-bottom: none; } .suggestion-text { margin-right: 10px; flex-grow: 1; color: var(--text-color); } .suggestion-text strong { color: var(--link-color); } .suggestion-actions button { padding: 4px 8px; font-size: 0.85em; cursor: pointer; margin-left: 5px; border: 1px solid var(--button-suggestion-border); background-color: var(--button-suggestion-bg); color: var(--text-color); border-radius: 3px; } .suggestion-actions button:hover { background-color: var(--button-suggestion-hover-bg); border-color: var(--border-color); }
        .slider-container { margin-top: 15px; padding-top: 10px; border-top: 1px solid var(--border-dashed-color); text-align: center; } .slider-container label { margin-right: 10px; font-size: 0.9em; color: var(--text-muted-color); vertical-align: middle; } #fuzzyThresholdSlider { width: 150px; vertical-align: middle; cursor: pointer; accent-color: var(--slider-thumb-bg); background: var(--slider-track-bg); } #fuzzyThresholdValue { display: inline-block; min-width: 30px; font-weight: bold; margin-left: 5px; color: var(--link-color); vertical-align: middle; }
        #settings-container { padding: 20px; } #settings-container .button-group { margin-top: 15px; display: flex; justify-content: center; gap: 10px;} #settings-container .button-group button { padding: 8px 15px; font-size: 0.9em;}
        .theme-switch-wrapper { display: flex; align-items: center; justify-content: center; margin-top: 10px; margin-bottom: 15px; }
        .theme-switch { display: inline-block; height: 24px; position: relative; width: 48px; } .theme-switch input { display: none; } .slider { background-color: var(--switch-bg); bottom: 0; cursor: pointer; left: 0; position: absolute; right: 0; top: 0; transition: .4s; border-radius: 24px; } .slider:before { background-color: var(--switch-thumb-bg); bottom: 3px; content: ""; height: 18px; left: 3px; position: absolute; transition: .4s; width: 18px; border-radius: 50%; } input:checked + .slider { background-color: var(--switch-checked-bg); } input:checked + .slider:before { transform: translateX(24px); } .theme-switch-wrapper span { margin-left: 8px; font-size: 0.9em; color: var(--text-muted-color); }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--modal-overlay-bg); display: none; justify-content: center; align-items: center; z-index: 1000; } .modal-content { background-color: var(--modal-content-bg); padding: 30px; border-radius: 8px; width: 90%; max-width: 700px; max-height: 80vh; overflow-y: auto; border: 1px solid var(--modal-border); position: relative; } .modal-content h3 { margin-top: 0; text-align: center; color: var(--heading-color); } .modal-close-button { position: absolute; top: 10px; right: 15px; font-size: 1.8em; font-weight: bold; color: var(--text-muted-color); background: none; border: none; cursor: pointer; line-height: 1; padding: 0; } .modal-close-button:hover { color: var(--text-color); } #vocabManagerList { list-style: none; padding: 0; margin-top: 20px; } #vocabManagerList li { display: flex; justify-content: space-between; align-items: center; padding: 10px 5px; border-bottom: 1px solid var(--border-light-color); } #vocabManagerList li:last-child { border-bottom: none; } .vocab-item-key { font-weight: bold; margin-right: 10px; color: var(--link-color); flex-basis: 40%; overflow-wrap: break-word; } .vocab-item-value { margin-right: 15px; color: var(--text-color); flex-grow: 1; overflow-wrap: break-word;} .vocab-item-actions button { padding: 4px 8px; font-size: 0.85em; cursor: pointer; margin-left: 5px; border-radius: 3px; border: 1px solid var(--button-suggestion-border); background-color: var(--button-suggestion-bg); color: var(--text-color); } .vocab-item-actions button.delete { background-color: var(--button-danger-bg); color: var(--button-danger-text); border-color: var(--button-danger-bg); } .vocab-item-actions button:hover { opacity: 0.8; } .modal-actions { margin-top: 25px; text-align: center; } .modal-actions button { padding: 10px 20px; font-size: 1em; }
    </style>
</head>
<body class="light-mode">

    <!-- Layout Principal -->
    <div class="layout-wrapper">
        <!-- Columna Izquierda -->
        <div class="main-content-area">
            <div class="container"> <h1>Dictado Radiológico <small>(v20 Corregido)</small></h1> </div>
            <div class="container controls"> <button id="toggleButton" class="start" disabled>Inicializando...</button> <button id="correctTextButton" disabled>Corregir Selección</button> <button id="copyTextButton" disabled>Copiar Texto</button> <p id="status">Estado: Inicializando...</p> <p class="instructions"><em>Selecciona texto y pulsa "Corregir Selección".</em></p> </div>
            <div class="container header-section"> <h3>Técnica Aplicada:</h3> <textarea id="headerArea" rows="3" placeholder="Selecciona una técnica o escribe aquí..."></textarea> </div>
            <div class="container editor-container"> <textarea id="reportArea" placeholder="El informe aparecerá aquí..." disabled></textarea> </div>
        </div>
        <!-- Columna Derecha -->
        <div class="suggestions-column">
            <div class="container" id="settings-container"> <h3>Ajustes</h3> <div class="theme-switch-wrapper"> <label class="theme-switch" for="themeToggleCheckbox"> <input type="checkbox" id="themeToggleCheckbox"> <span class="slider"></span> </label> <span>Tema Oscuro</span> </div> <div class="slider-container"> <label for="fuzzyThresholdSlider">Sensibilidad Sugerencias:</label> <input type="range" id="fuzzyThresholdSlider" min="0.1" max="0.8" step="0.05" value="0.3"> <span id="fuzzyThresholdValue">0.30</span> </div> <div class="button-group"> <button id="manageVocabButton" class="btn-blue" disabled>Gestionar Vocabulario</button> </div> </div>
            <div class="container" id="technique-selection-container"> <h3>Seleccionar Técnica</h3> <div id="techniqueButtons"> <div class="technique-group"> <button class="btn-red" data-technique-text="TAC abdominal con contraste IV en fases arterial y portal.">Abd Art+Portal</button> <button class="btn-red" data-technique-text="TAC abdominal con contraste IV en fase portal.">Abd Portal</button> <button class="btn-red" data-technique-text="TAC toraco-abdominal con contraste IV en fases arterial y portal.">Tórax+Abd Art+Portal</button> <button class="btn-red" data-technique-text="TAC abdominal sin y con contraste IV para valoración de hernia. Maniobra de Valsalva.">Abd Hernia</button> <button class="btn-red" data-technique-text="TAC abdominal sin y con contraste IV en fases arterial, portal y tardía.">Abd 3 Fases</button> <button class="btn-blue" data-technique-text="Ecografía abdominal convencional con transductor convexo.">Eco Abd</button> </div> <div class="technique-group"> <button class="btn-yellow" data-technique-text="RM hepática con secuencias T1, T2, difusión y estudio dinámico tras contraste hepatoespecífico.">RM Hepática</button> <button class="btn-yellow" data-technique-text="Colangio-RM con secuencias potenciadas en T2 y cortes finos 3D.">ColangioRM</button> <button class="btn-yellow" data-technique-text="Entero-RM con contraste oral y secuencias T1, T2, difusión tras contraste IV.">EnteroRM</button> <button class="btn-yellow" data-technique-text="RM pélvica para valoración de fístulas con contraste IV.">RM Fístulas</button> <button class="btn-yellow" data-technique-text="RM pélvica para estadiaje de neoplasia rectal/vesical/prostática con contraste IV.">RM Neo Pelvis</button> <button id="clearHeaderButton" class="btn-gray">Borrar Técnica</button> </div> </div> </div>
            <div class="container suggestions-container"> <h3>Sugerencias de Corrección</h3> <div id="fuzzySuggestionsList"><small>No hay sugerencias.</small></div> </div>
        </div>
    </div>

    <!-- Modal Gestionar Vocabulario -->
    <div id="vocabManagerModal" class="modal-overlay"> <div class="modal-content"> <button id="modalCloseButton" class="modal-close-button">×</button> <h3>Gestionar Vocabulario</h3> <ul id="vocabManagerList"></ul> <div class="modal-actions"> <button id="modalAddNewRuleButton" class="btn-green">Añadir Nueva Regla</button> </div> </div> </div>

    <!-- Script Principal -->
    <script type="module">
        document.addEventListener('firebaseReady', () => {
            initializeDictationApp();
        });

        async function initializeDictationApp() {
            // --- Selección DOM ---
            const toggleButton = document.getElementById('toggleButton'); const statusDiv = document.getElementById('status'); const reportArea = document.getElementById('reportArea'); const correctTextButton = document.getElementById('correctTextButton'); const copyTextButton = document.getElementById('copyTextButton'); const fuzzySuggestionsList = document.getElementById('fuzzySuggestionsList'); const fuzzyThresholdSlider = document.getElementById('fuzzyThresholdSlider'); const fuzzyThresholdValueSpan = document.getElementById('fuzzyThresholdValue'); const themeToggleCheckbox = document.getElementById('themeToggleCheckbox'); const headerArea = document.getElementById('headerArea'); const techniqueButtonsContainer = document.getElementById('techniqueButtons'); const clearHeaderButton = document.getElementById('clearHeaderButton'); const manageVocabButton = document.getElementById('manageVocabButton'); const vocabManagerModal = document.getElementById('vocabManagerModal'); const modalCloseButton = document.getElementById('modalCloseButton'); const vocabManagerList = document.getElementById('vocabManagerList'); const modalAddNewRuleButton = document.getElementById('modalAddNewRuleButton');
            reportArea.disabled = false;

            // --- Variables Globales ---
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            let recognition; let customVocabulary = {}; let customVocabularyKeys = []; let sortedVocabKeys = []; let recognizing = false; let timeoutHandle = null; let fuse; let fuzzyMatchesFound = new Map(); let learnedCorrections = {};
            const db = window.db; const doc = window.doc; const getDoc = window.getDoc; const setDoc = window.setDoc; const userId = window.userId;
            if (!db || !doc || !getDoc || !setDoc || !userId) { console.error("Dependencias Firebase no encontradas."); statusDiv.textContent = "Error: Fallo DB."; toggleButton.disabled = true; correctTextButton.disabled = true; copyTextButton.disabled = true; reportArea.disabled = true; manageVocabButton.disabled = true; return; }
            const vocabDocRef = doc(db, "vocabularies", userId);
            let currentFuzzyThreshold = 0.3; const FUSE_DEFAULTS = { includeScore: true, minMatchCharLength: 4 }; const LEARNED_CORRECTION_THRESHOLD = 3;

            // --- Lógica Tema ---
            function applyTheme(theme) { document.body.className = theme === 'dark' ? 'dark-mode' : 'light-mode'; themeToggleCheckbox.checked = theme === 'dark'; }
            function toggleTheme() { const currentTheme = document.body.classList.contains('dark-mode') ? 'light' : 'dark'; applyTheme(currentTheme); localStorage.setItem('themePreference', currentTheme); }
            const savedTheme = localStorage.getItem('themePreference') || 'light'; applyTheme(savedTheme);
            themeToggleCheckbox.addEventListener('change', toggleTheme);

            // --- Gestión Vocabulario (Firestore) ---
            function initializeFuse() { if (customVocabularyKeys.length > 0) { const fuseOptions = { ...FUSE_DEFAULTS, threshold: currentFuzzyThreshold }; fuse = new Fuse(customVocabularyKeys, fuseOptions); } else { fuse = null; } }
            function initializeThreshold() { currentFuzzyThreshold = parseFloat(fuzzyThresholdSlider.value); fuzzyThresholdValueSpan.textContent = currentFuzzyThreshold.toFixed(2); }
            function processLoadedVocabularyData(rulesData, learnedData) { customVocabulary = rulesData || {}; learnedCorrections = learnedData || {}; customVocabularyKeys = Object.keys(customVocabulary); updateSortedKeys(); initializeFuse(); console.log(`Vocab procesado: ${customVocabularyKeys.length} reglas, ${Object.keys(learnedCorrections).length} aprendidas.`); statusDiv.textContent = 'Listo'; toggleButton.disabled = false; toggleButton.textContent = 'Empezar Dictado'; toggleButton.classList.remove('stop'); toggleButton.classList.add('start'); correctTextButton.disabled = false; copyTextButton.disabled = false; manageVocabButton.disabled = false; }
            async function loadVocabularyFromFirestore() { console.log(`Cargando vocab para ${userId}`); toggleButton.disabled = true; toggleButton.textContent = 'Cargando...'; correctTextButton.disabled = true; copyTextButton.disabled = true; manageVocabButton.disabled = true; statusDiv.textContent = 'Cargando datos...'; try { const docSnap = await getDoc(vocabDocRef); if (docSnap.exists()) { const data = docSnap.data(); const rulesMap = (data && typeof data.rulesMap === 'object' && data.rulesMap !== null) ? data.rulesMap : {}; const learnedMap = (data && typeof data.learnedMap === 'object' && data.learnedMap !== null) ? data.learnedMap : {}; processLoadedVocabularyData(rulesMap, learnedMap); } else { processLoadedVocabularyData({}, {}); } } catch (error) { console.error("Error cargando vocab:", error); alert("Error al cargar vocabulario."); processLoadedVocabularyData({}, {}); statusDiv.textContent = 'Error carga vocab.'; toggleButton.textContent = 'Error Carga'; } }
            async function saveVocabularyToFirestore(vocabToSave, learnedToSave) { console.log(`Guardando ${Object.keys(vocabToSave).length} reglas y ${Object.keys(learnedToSave).length} correcciones...`); try { await setDoc(vocabDocRef, { rulesMap: vocabToSave, learnedMap: learnedToSave }, { merge: true }); console.log("Datos guardados Firestore."); processLoadedVocabularyData(vocabToSave, learnedToSave); } catch (error) { console.error("Error guardando Firestore:", error); alert("Error al guardar en DB."); throw error; } }
            function updateSortedKeys() { sortedVocabKeys = Object.keys(customVocabulary).sort((a, b) => b.length - a.length); }
            function escapeRegExp(string) { return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
            function normalizeText(text) { if (!text) return ''; return text.toLowerCase().replace(/[.,:;!?()]/g, '').replace(/\s+/g, ' ').trim(); }

             // --- Lógica Fuzzy, Sugerencias y Aprendizaje ---
            function applyLearnedCorrections(text) { let correctedText = text; const textLower = text.toLowerCase(); for (const mistakeNorm in learnedCorrections) { const correctionData = learnedCorrections[mistakeNorm]; if (correctionData.count >= LEARNED_CORRECTION_THRESHOLD) { try { const mistakeRegex = new RegExp(`\\b${escapeRegExp(mistakeNorm)}\\b`, 'gi'); if (mistakeRegex.test(correctedText)) { console.log(`Applying learned correction: "${mistakeNorm}" -> "${correctionData.correctKey}"`); correctedText = correctedText.replace(mistakeRegex, correctionData.correctKey); } } catch (e) {} } } return correctedText; }
            function checkFuzzyMatches(originalText) { if (!fuse || !originalText || originalText.length < FUSE_DEFAULTS.minMatchCharLength) return; const normalizedOriginal = normalizeText(originalText); if (!normalizedOriginal || fuzzyMatchesFound.has(normalizedOriginal)) return; const results = fuse.search(normalizedOriginal); if (results.length > 0) { const bestMatch = results[0]; if (bestMatch.score < currentFuzzyThreshold + 0.001) { const matchedKey = bestMatch.item; const suggestedValue = customVocabulary[matchedKey]; if (matchedKey !== normalizedOriginal) { const suggestionData = { original: originalText, matchedKey: matchedKey, suggestedValue: suggestedValue, score: bestMatch.score }; fuzzyMatchesFound.set(normalizedOriginal, suggestionData); displayFuzzySuggestion(suggestionData); }}}}
            function applyCustomVocabulary(text) { let p = text; for (const key of sortedVocabKeys) { const v = customVocabulary[key]; try { const r = new RegExp(`\\b${escapeRegExp(key)}\\b`, 'gi'); p = p.replace(r, v); } catch (e) {} } return p; }
            function displayFuzzySuggestion(suggestionData = null) { if (!suggestionData && fuzzyMatchesFound.size === 0) { fuzzySuggestionsList.innerHTML = '<small>No hay sugerencias.</small>'; return; } if (fuzzyMatchesFound.size === 1 && suggestionData) { fuzzySuggestionsList.innerHTML = ''; } if (suggestionData) { const item = document.createElement('div'); item.className = 'suggestion-item'; item.innerHTML = `<span class="suggestion-text">"${suggestionData.original}" (${(suggestionData.score*100).toFixed(0)}%) ≈ "${suggestionData.matchedKey}". ¿Usar: "<strong>${suggestionData.suggestedValue}</strong>"?</span><span class="suggestion-actions"><button data-original="${suggestionData.original}" data-matched-key="${suggestionData.matchedKey}" data-suggested-value="${suggestionData.suggestedValue}">Añadir Regla</button><button data-dismiss-key="${normalizeText(suggestionData.original)}">Ignorar</button></span>`; item.querySelector('[data-original]').addEventListener('click', handleAddFuzzyRule); item.querySelector('[data-dismiss-key]').addEventListener('click', handleDismissFuzzy); fuzzySuggestionsList.appendChild(item); } }
            async function handleAddFuzzyRule(event) { const btn = event.target; const original = btn.dataset.original; const suggestedValue = btn.dataset.suggestedValue; const originalLower = original.toLowerCase(); const matchedKeyLower = btn.dataset.matchedKey.toLowerCase(); let vocabChanged = false; if (!customVocabulary.hasOwnProperty(originalLower)) { customVocabulary[originalLower] = suggestedValue; vocabChanged = true; } const mistakeNorm = normalizeText(original); const correctKeyNorm = normalizeText(matchedKeyLower); if (!learnedCorrections[mistakeNorm]) { learnedCorrections[mistakeNorm] = { correctKey: correctKeyNorm, count: 0 }; } learnedCorrections[mistakeNorm].count++; console.log(`Incrementado contador para "${mistakeNorm}": ${learnedCorrections[mistakeNorm].count}`); try { await saveVocabularyToFirestore(customVocabulary, learnedCorrections); alert(`Regla "${original} -> ${suggestedValue}" añadida/confirmada.`); btn.closest('.suggestion-item').remove(); if (fuzzySuggestionsList.childElementCount === 0) fuzzySuggestionsList.innerHTML = '<small>No hay sugerencias.</small>'; fuzzyMatchesFound.delete(normalizeText(original)); } catch (error) { alert("Error al guardar cambios."); if (vocabChanged) { delete customVocabulary[originalLower]; } if (learnedCorrections[mistakeNorm]) { learnedCorrections[mistakeNorm].count--; if (learnedCorrections[mistakeNorm].count <= 0) delete learnedCorrections[mistakeNorm]; } } }
            function handleDismissFuzzy(event) { const btn = event.target; const keyToDismiss = btn.dataset.dismissKey; fuzzyMatchesFound.delete(keyToDismiss); btn.closest('.suggestion-item').remove(); if (fuzzySuggestionsList.childElementCount === 0) fuzzySuggestionsList.innerHTML = '<small>No hay sugerencias.</small>'; }
            function clearSuggestions() { fuzzyMatchesFound.clear(); fuzzySuggestionsList.innerHTML = '<small>No hay sugerencias.</small>'; }

            // --- Lógica Principal Reconocimiento ---
            if (SpeechRecognition) {
                recognition = new SpeechRecognition();
                recognition.lang = 'es-ES'; recognition.continuous = true; recognition.interimResults = true;

                function updateButtonState(isRecognizing, statusHTML = '') { recognizing = isRecognizing; if (isRecognizing) { toggleButton.textContent = 'Detener Dictado'; toggleButton.classList.remove('start'); toggleButton.classList.add('stop'); statusDiv.innerHTML = statusHTML || 'Escuchando...'; } else { toggleButton.textContent = 'Empezar Dictado'; toggleButton.classList.remove('stop'); toggleButton.classList.add('start'); statusDiv.innerHTML = statusHTML || 'Detenido.'; setTimeout(capitalizeSentences, 100); } toggleButton.disabled = false; }
                recognition.onstart = () => { updateButtonState(true); fuzzyMatchesFound.clear(); displayFuzzySuggestion(); };
                recognition.onend = () => { if (recognizing) { updateButtonState(false); } clearTimeout(timeoutHandle); };
                recognition.onerror = (event) => { let msg = 'Error: ' + event.error; let stop = true; if (event.error === 'no-speech') { msg = 'Error: No voz.'; stop = false; statusDiv.innerHTML = `Estado: ${msg}`; } else { msg = `Error: ${event.error}.`; } if (stop) { if(recognition) { try { recognition.stop(); } catch(e){} } updateButtonState(false, `Estado: ${msg} Detenido.`); }};

                 recognition.onresult = (event) => {
                    let interim = ''; let currentFinal = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) { const part = event.results[i][0].transcript; if (event.results[i].isFinal) { currentFinal += part; } else { interim += part; } }
                    if (recognizing && interim) { statusDiv.innerHTML = `Escuchando: <span style="color:var(--status-listening-color);font-style:italic;">${interim}</span>`; } else if (recognizing) { statusDiv.innerHTML = 'Escuchando...'; }
                    if (currentFinal.trim()) { const original = currentFinal.trim(); checkFuzzyMatches(original); let processed = processTranscriptSegment(original); updateReportArea(processed); }
                    clearTimeout(timeoutHandle); timeoutHandle = setTimeout(() => { if (recognizing) { if(recognition) { try { recognition.stop(); } catch(e){} } } }, 20000);
                };

                 // --- Procesamiento de Segmento ---
                 function processTranscriptSegment(transcript) { let p = transcript; p = applyLearnedCorrections(p); p = applyCustomVocabulary(p); p = p.replace(/\bpunt(?:o)? y aparte\b\s*/gi,'.\n').replace(/\bpunt(?:o)? y seguido\b\s*/gi,'. ').replace(/\bpunto\b\s*/gi,'. ').replace(/\bcoma\b\s*/gi,', ').replace(/\bnueva l(?:í|i)nea\b\s*/gi,'\n').replace(/\babrir par(?:é|e)ntesis\b\s*/gi,' (').replace(/\bcerrar par(?:é|e)ntesis\b\s*/gi,') ').replace(/\bdos puntos\b\s*/gi,': ').replace(/\binterrogaci(?:ó|o)n\b\s*/gi,'? ').replace(/\bexclamaci(?:ó|o)n\b\s*/gi,'! ').replace(/\bguin(?:o|ó)n\b\s*/gi,' - ').replace(/\bbarra\b\s*/gi,'/'); p = p.replace(/\s+([.,:;!?\)])/g,'$1').replace(/([.,:;!?\(\)])\s*([.,:;!?\(\)])/g,'$1 $2').replace(/[ \t]+/g,' ').replace(/([.,])(?![\s\n\)])/g,'$1 ').replace(/ \./g,'.'); return p.trimStart(); }

                // --- Actualización Textarea (Lógica contextual) ---
                function updateReportArea(newText) { if (!newText && newText !== 0) return; let finalText = newText.trimStart(); if (!finalText && finalText !== 0) return; const start = reportArea.selectionStart; const end = reportArea.selectionEnd; const current = reportArea.value; let before = current.substring(0, start); let after = current.substring(end); const cap = shouldBeCapitalized(current, start); if (cap && finalText.length > 0) { finalText = finalText.replace(/^[a-záéíóúü]/, m => m.toUpperCase()); } let leadSpace = false; if (before.length > 0) { const lastB = before.slice(-1); if (!/[\s\n\(]/.test(lastB) && !/^[\s\n.,:;!?\)\)\]]/.test(finalText)) leadSpace = true; } let trailSpace = false; if (after.length > 0) { const lastI = finalText.slice(-1); if (!/[\s\n\(]/.test(lastI) && !/^[\s\n.,:;!?\)\)\]]/.test(after)) trailSpace = true; } const lSpace = leadSpace ? ' ' : ''; const tSpace = trailSpace ? ' ' : ''; const finalIns = lSpace + finalText + tSpace; reportArea.value = before + finalIns + after; const finalPos = start + finalIns.length; reportArea.selectionStart = reportArea.selectionEnd = finalPos; reportArea.scrollTop = reportArea.scrollHeight; }

                 // --- Funciones Capitalización ---
                 function shouldBeCapitalized(currentText, cursorPos) { if (cursorPos === 0) return true; let lookBehind = currentText.substring(Math.max(0, cursorPos - 1), cursorPos); if (lookBehind === '\n') return true; lookBehind = currentText.substring(Math.max(0, cursorPos - 3), cursorPos).trimEnd(); if (lookBehind.endsWith('.') || lookBehind.endsWith('!') || lookBehind.endsWith('?')) { return true; } return false; }
                 function capitalizeSentences() { let text = reportArea.value; text = text.replace(/(^|[\.\!\?]\s*\n*)\s*([a-záéíóúü])/g, (_, p1, p2) => { return p1 + p2.toUpperCase(); }); if (text.length > 0) { text = text.replace(/^(\s*)([a-záéíóúü])/, (_, p1, p2) => p1 + p2.toUpperCase()); } reportArea.value = text; }

                 // --- Función para Corregir Selección ---
                 async function handleCorrectTextSelection() { const start = reportArea.selectionStart; const end = reportArea.selectionEnd; const sel = reportArea.value.substring(start, end).trim(); if (start === end || !sel) { alert("Selecciona texto."); return; } if (sel.includes("->")) { alert("Selección inválida."); return; } const corr = window.prompt(`Corregir:\n"${sel}"\n\nCorrecto:`, sel); if (corr === null || corr.trim() === "") return; const corrT = corr.trim(); const selLow = sel.toLowerCase(); if(customVocabulary.hasOwnProperty(selLow) && customVocabulary[selLow] === corrT) { alert("Corrección ya existe."); if (sel !== corrT) { const bef = reportArea.value.substring(0, start); const aft = reportArea.value.substring(end); reportArea.value = bef + corrT + aft; reportArea.selectionStart = reportArea.selectionEnd = start + corrT.length; reportArea.focus(); } return; } const bef = reportArea.value.substring(0, start); const aft = reportArea.value.substring(end); reportArea.value = bef + corrT + aft; reportArea.selectionStart = reportArea.selectionEnd = start + corrT.length; reportArea.focus(); customVocabulary[selLow] = corrT; try { await saveVocabularyToFirestore(customVocabulary, learnedCorrections); alert(`Corrección aplicada y regla guardada.`); } catch (error) { alert("Error al guardar corrección."); if(customVocabulary.hasOwnProperty(selLow)) { delete customVocabulary[selLow]; } } }

                 // --- Función para Copiar Texto ---
                 async function handleCopyText() { const headerText = headerArea.value || ''; const reportText = reportArea.value || ''; const trimmedHeaderText = headerText.trim(); const trimmedReportText = reportText.trim(); let textToCopy = ""; if (trimmedHeaderText && trimmedReportText) { textToCopy = trimmedHeaderText + '\n\n' + trimmedReportText; } else if (trimmedReportText) { textToCopy = trimmedReportText; } else if (trimmedHeaderText) { textToCopy = trimmedHeaderText; } if (!textToCopy) return; try { await navigator.clipboard.writeText(textToCopy); const originalText = copyTextButton.textContent; copyTextButton.textContent = '¡Copiado!'; copyTextButton.disabled = true; setTimeout(() => { copyTextButton.textContent = originalText; if (!toggleButton.disabled || toggleButton.textContent !== 'Cargando...') { copyTextButton.disabled = false; } }, 1500); } catch (err) { console.error('Error al copiar: ', err); alert('Error al copiar texto.'); } }

                 // --- Funciones para Gestionar Vocabulario (Modal - CORREGIDAS CON GUARDADO) ---
                 function openVocabManager() { populateVocabManager(); vocabManagerModal.style.display = 'flex'; }
                 function closeVocabManager() { vocabManagerModal.style.display = 'none'; }
                 function populateVocabManager() {
                     vocabManagerList.innerHTML = ''; const sortedKeys = Object.keys(customVocabulary).sort();
                     if (sortedKeys.length === 0) { vocabManagerList.innerHTML = '<li>No hay reglas.</li>'; return; }
                     sortedKeys.forEach(key => { const value = customVocabulary[key]; const li = document.createElement('li'); li.innerHTML = `<span class="vocab-item-key">${key}</span> <span class="vocab-item-value">${value}</span> <span class="vocab-item-actions"> <button data-key="${key}">Editar</button> <button data-key="${key}" class="delete">Borrar</button> </span>`; li.querySelector('button[data-key]:not(.delete)').addEventListener('click', handleVocabEdit); li.querySelector('button.delete[data-key]').addEventListener('click', handleVocabDelete); vocabManagerList.appendChild(li); });
                 }
                 async function handleVocabEdit(event) {
                    const keyToEdit = event.target.dataset.key; const currentValue = customVocabulary[keyToEdit];
                    const newKeyPrompt = window.prompt(`Editar clave:\nActual: "${keyToEdit}"\nNuevo:`, keyToEdit); if (newKeyPrompt === null) return;
                    const newKey = newKeyPrompt.trim().toLowerCase(); if (!newKey) { alert("Clave vacía."); return; }
                    const newValuePrompt = window.prompt(`Editar valor para "${newKey}":\nActual: "${currentValue}"\nNuevo:`, currentValue); if (newValuePrompt === null) return;
                    const newValue = newValuePrompt.trim(); if (!newValue) { alert("Valor vacío."); return; }
                    const originalValueBackup = customVocabulary[keyToEdit]; let changedKey = false;
                    if (newKey !== keyToEdit) { delete customVocabulary[keyToEdit]; changedKey = true; } customVocabulary[newKey] = newValue;
                    try {
                         await saveVocabularyToFirestore(customVocabulary, learnedCorrections); // *** GUARDAR ***
                         populateVocabManager(); alert("Regla actualizada.");
                    } catch (error) {
                         alert("Error al guardar."); delete customVocabulary[newKey]; if (changedKey) { customVocabulary[keyToEdit] = originalValueBackup; } else { customVocabulary[keyToEdit] = originalValueBackup; } populateVocabManager();
                    }
                 }
                 async function handleVocabDelete(event) {
                     const keyToDelete = event.target.dataset.key;
                     if (confirm(`¿Borrar regla para "${keyToDelete}"?`)) {
                         const valueBackup = customVocabulary[keyToDelete]; delete customVocabulary[keyToDelete];
                         try {
                             await saveVocabularyToFirestore(customVocabulary, learnedCorrections); // *** GUARDAR ***
                             populateVocabManager(); alert("Regla borrada.");
                         } catch (error) {
                             alert("Error al borrar."); customVocabulary[keyToDelete] = valueBackup; populateVocabManager();
                         }
                     }
                 }
                 async function handleAddNewRule() {
                     const newKeyPrompt = window.prompt("Frase a dictar (clave):"); if (newKeyPrompt === null || !newKeyPrompt.trim()) return;
                     const newKey = newKeyPrompt.trim().toLowerCase(); if (customVocabulary.hasOwnProperty(newKey)) { alert(`Clave "${newKey}" ya existe.`); return; }
                     const newValuePrompt = window.prompt(`Texto de reemplazo para "${newKey}":`); if (newValuePrompt === null || !newValuePrompt.trim()) return;
                     const newValue = newValuePrompt.trim(); customVocabulary[newKey] = newValue;
                     try {
                         await saveVocabularyToFirestore(customVocabulary, learnedCorrections); // *** GUARDAR ***
                         populateVocabManager(); alert("Nueva regla añadida.");
                     } catch (error) {
                          alert("Error al añadir regla."); delete customVocabulary[newKey]; populateVocabManager();
                     }
                 }


                // --- Event Listeners ---
                 toggleButton.addEventListener('click', () => {
                     if (!SpeechRecognition || toggleButton.disabled) return;
                     if (recognizing) {
                         if (recognition) { try { recognition.stop(); } catch (e) { console.error("Error stop:", e); updateButtonState(false, 'Error al detener'); } }
                     } else {
                         try { if (recognition) { recognition.start(); toggleButton.disabled = true; updateButtonState(true, 'Iniciando...'); } else { throw new Error("No recognition"); } }
                         catch (e) { console.error("Error start:", e); updateButtonState(false, 'Error al iniciar.'); }
                     }
                 });
                correctTextButton.addEventListener('click', handleCorrectTextSelection);
                copyTextButton.addEventListener('click', handleCopyText);
                fuzzyThresholdSlider.addEventListener('input', (event) => { currentFuzzyThreshold = parseFloat(event.target.value); fuzzyThresholdValueSpan.textContent = currentFuzzyThreshold.toFixed(2); initializeFuse(); clearSuggestions(); });
                techniqueButtonsContainer.addEventListener('click', (event) => { if (event.target.tagName === 'BUTTON' && event.target.dataset.techniqueText) { headerArea.value = event.target.dataset.techniqueText; } });
                clearHeaderButton.addEventListener('click', () => { headerArea.value = ''; });
                manageVocabButton.addEventListener('click', openVocabManager);
                modalCloseButton.addEventListener('click', closeVocabManager);
                modalAddNewRuleButton.addEventListener('click', handleAddNewRule);
                vocabManagerModal.addEventListener('click', (event) => { if (event.target === vocabManagerModal) { closeVocabManager(); } });

                // --- Inicialización ---
                initializeThreshold();
                await loadVocabularyFromFirestore(); // Cargar vocab y correcciones

            } else {
                statusDiv.textContent = 'Error: Navegador no soporta Web Speech API.';
                toggleButton.disabled = true; correctTextButton.disabled = true; copyTextButton.disabled = true; reportArea.disabled = true; fuzzyThresholdSlider.disabled = true; manageVocabButton.disabled = true;
                alert('Navegador no compatible.');
            }
        } // Fin initializeDictationApp
    </script>

</body>
</html>
